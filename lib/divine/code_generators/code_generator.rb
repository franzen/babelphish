require 'digest/sha1'

module Divine
  $language_generators = {}
  
  class BabelHelperMethods
    def format_src(first_indent, following_indent, is, spc = " ")
      indent = "#{spc * first_indent}"
      is.flatten.compact.map do |i|
        case i
        when :indent
          indent << spc * following_indent
          nil
        when :deindent
          indent = indent[0..-(following_indent+1)]
          nil
        else
          "#{indent}#{i}"
        end
      end.compact.join("\n")
    end
    
    def get_fresh_variable_name
      @vindex = (@vindex || 0xFF) + 1
      return "var_#{@vindex.to_s(16)}"
    end
    
    def camelize(*str)
      ss = str.map(&:to_s).join("_").split(/_/).flatten
      "#{ss.first.downcase}#{ss[1..-1].map(&:downcase).map(&:capitalize).join}"
    end
    
    def get_header_comment_text
      return [
        "",
        "-- DO NOT EDIT THIS FILE! --", "",
        "This source code was generated by Divine #{Divine::VERSION} at #{Time.now.to_s}", "",
        "-- DO NOT EDIT THIS FILE! --", ""
      ]
    end
    
    #
    # Sanity check the different revisions of the struct
    #
    def sanity_check(ss)
      vos = ss.sort do |x,y|
        v1,v2 = [x,y].map(&:version)
        v1 <=> v2
      end

      # Check version numbers
      unless vos.map(&:version).uniq.size == ss.size
        raise "Inconsistent version numbering for '#{ss.first.name}': #{vos.map(&:version).join(', ')}"
      end
      
      # Check types between versions
      check_field_types(vos)
      
      # Check for changed definitions
      check_freezed_structs(vos)
    end
    
    private
    #
    # Check types through all versions, we're not allowed to change the type of a variable between different versions
    #
    def check_field_types(ss)
      types = {}
      ss.each do |x|
        x.fields.each do |f|
          if types[f.name]
            unless same_type(types[f.name], x, f.name)
              raise "Cannot change the field type for struct #{x.name}.#{f.name} between version #{types[f.name].version} and #{x.version}"
            end
          else
            types[f.name] = x
          end
        end
      end
    end
    
    def same_type(t1, t2, field)
      t1.get_field(field).referenced_types == t2.get_field(field).referenced_types
    end
    
    def check_freezed_structs(ss)
      ss.each do |s|
        if s.freezed?
          sig = calculate_signature(s)
          unless sig == s.freeze_signature
            raise "Struct '#{s.name}', version #{s.version} has changed! Got signature '#{sig}', expected '#{s.freeze_signature}'"
          end
        end
      end
    end
    
    def calculate_signature(s)
      str = s.fields.map do |f|
        "#{f.name}:#{f.referenced_types.inspect}"
      end.join(",")
      Digest::SHA1.hexdigest("#{s.name}:#{s.version},#{str}")
    end
  end
  
  
  
  class CodeGenerator
    def generate(target, opts)
      gen = $language_generators[target.to_sym]
      raise "Unknown target language: #{target}" unless gen
      puts "Generating code for #{target}"
      src = gen.generate_code($all_structs, opts)
      target_dir = getTargetDir(opts[:target_dir])

      if opts[:package]
        path = target_dir + opts[:package]
        Dir.mkdir(path) unless File.exists?(path)
        for cls in src
           file_name = path+"/"+cls[:file]
           writeFile(file_name, cls[:src])
        end
      elsif opts[:file]
        path = target_dir + opts[:file]
        writeFile(path, src[0][:src])
      else
        puts src
      end
    end

    def getTargetDir(dir)
      # check if the path is relative or absolute if exist
      if dir && File.directory?(dir)
        return dir + "/"
      elsif dir && File.directory?(Dir.pwd + "/" + dir)
        return Dir.pwd + dir + "/"
      end
      ""
    end
    
    def writeFile(path, content)
      File.open(path, 'w+') do |f|
        puts "... writing #{path}"
        f.write(content)
      end
    end
  end
end
